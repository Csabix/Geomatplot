function h = Image(varargin)% Image  visualizes a given 2D function over an area%   Image({A,B,...},callback) draws an image using the given callback function handle of the form%           callback(X,Y,A,B,...) -> C%       where A,B,... are n >= 1 number of any Geomaplot handles, and their values will be passed to%       the given callback. For example, if A is a point, then its position vector [x y] will be%       given to the callback to calculate with. The parameter X and Y are given automatically and%       are NxM matrices retuned from a meshgrid command. The X(i,j) and Y(i,j) position corresponds%       to the position it appears on the canvas. The output is expected to be an NxM array of%       function evaluations or NxMx3 array for colors.%       Note that if the callback throws any error, the excecution does not stop, the image goes%       into the 'undefined' state and it will not be drawn.%       For example, the following visualizes the distance function of a single point:%           Image({Point},)%%   Image({A,B,...},callback,corner0,corner1)  specifies a corners (eg. lower left and upper right)%       of the plotted region. The values may be two element position vectors, or even point objects%       allowing for dynamically changing the visualized function domain. The default corners are%       [0,0] and [1,1]. %%   Image(label,{___})  provides a label for the curve. The label is not drawn.%%   Image(parent,___)  draws onto the given geomatplot, axes, or figure instead of%       the current one. Thus must preceed the label argument if that is given also.%%   Image(___,Name,Value)  specifies additional properties using one or more Name,%       Value pairs arguments.%%   h = Image(___)  returns the created handle.%%   See also Curve, POINT, DISTANCE, Circle    [parent,varargin] = Geomatplot.extractGeomatplot(varargin);      [label,varargin]  = parent.extractLabel(varargin,'image');    [inputs,varargin] = parent.extractInputs(varargin);    [usercallback,corner0,corner1,params,options]= parse_(inputs,varargin{:});    nins = length(inputs);    nout = abs(nargout(usercallback));    %% helper functions    function args = values_of(args)        if options.Complex            for i=1:length(args)                v = cast(args{i}.value,options.Type);                args{i} = complex(v(:,1),v(:,2));            end        else            for i=1:length(args)                args{i} = cast(args{i}.value,options.Type);            end        end    end        function [x,y] = linspace_meshgrid(xr,xn,yr,yn)        if options.gpuArray            x = gpuArray.linspace(cast(xr(1),options.Type),xr(2),xn);            y = gpuArray.linspace(cast(yr(1),options.Type),yr(2),yn);        else            x = linspace(cast(xr(1),options.Type),xr(2),xn);            y = linspace(cast(yr(1),options.Type),yr(2),yn);        end        [x,y] = meshgrid(x,y);        if nargout == 1; x = complex(x,y); end    end    %% callback zoo    function varargout = img_cpu_real_matrix(xr,xn,yr,yn,varargin)        [x,y] = linspace_meshgrid(xr,xn,yr,yn);        args = values_of(varargin);        if xn*yn > 1000*1000 && ~strcmp(options.Type,'half')            if isempty(gcp('nocreate')); parpool('Threads');end            switch nout            case 1                spmd                    lo = round((spmdIndex-1)*xn/spmdSize)+1;                     hi = round((spmdIndex+0)*xn/spmdSize)+0;                    r = usercallback(x(lo:hi,:),y(lo:hi,:),args{:});                end                varargout = {vertcat(r{:})};            case 3                spmd                    lo = round((spmdIndex-1)*xn/spmdSize)+1;                     hi = round((spmdIndex+0)*xn/spmdSize)+0;                    [r,g,b] = usercallback(x(lo:hi,:),y(lo:hi,:),args{:});                end                varargout = {vertcat(r{:}),vertcat(g{:}),vertcat(b{:})};            end        else            [varargout{1:nout}] = usercallback(x,y,args{:});        end    end       function varargout = img_cpu_cplx_matrix(xr,xn,yr,yn,varargin)        z = linspace_meshgrid(xr,xn,yr,yn);        args = values_of(varargin);        if xn*yn > 1000*1000 && ~strcmp(options.Type,'half')            if isempty(gcp('nocreate')); parpool('Threads');end            switch nout            case 1                spmd                    lo = round((spmdIndex-1)*xn/spmdSize)+1;                     hi = round((spmdIndex+0)*xn/spmdSize)+0;                    r = usercallback(z(lo:hi,:),args{:});                end                varargout = {vertcat(r{:})};            case 3                spmd                    lo = round((spmdIndex-1)*xn/spmdSize)+1;                     hi = round((spmdIndex+0)*xn/spmdSize)+0;                    [r,g,b] = usercallback(z(lo:hi,:),args{:});                end                varargout = {vertcat(r{:}),vertcat(g{:}),vertcat(b{:})};            end        else            [varargout{1:nout}] = usercallback(z,args{:});        end    end    function varargout = img_cpu_real_arrayfun(xr,xn,yr,yn,varargin)        args = values_of(varargin);        xa = xr(1); ya = yr(1);        xd = diff(xr); yd = diff(yr);        r = zeros(yn,xn);        if isempty(gcp('nocreate')); parpool('Threads');end        switch nout        case 1            parfor i=1:xn                x = xa+(i-1)/(xn-1)*xd;                ri = zeros(1,yn);                for j = 1:yn                    y = ya+(j-1)/(yn-1)*yd;                    ri(j) = usercallback(x,y,args{:}); %#ok<PFBNS>                 end                r(:,i) = ri;            end            varargout = {r};        case 3            g = r; b = r;            parfor i=1:xn                x = xa+(i-1)/(xn-1)*xd;                ri = zeros(1,yn); gi = ri; bi = ri;                for j = 1:yn                    y = ya+(j-1)/(yn-1)*yd;                    [ri(j),gi(j),bi(j)] = usercallback(x,y,args{:}); %#ok<PFBNS>                 end                r(:,i) = ri; g(:,i) = gi; b(:,i) = bi;            end            varargout = {r,g,b};        end    end    function varargout = img_cpu_cplx_arrayfun(xr,xn,yr,yn,varargin)        args = values_of(varargin);        xa = xr(1); ya = yr(1);        xd = diff(xr); yd = diff(yr);        r = zeros(yn,xn);        if isempty(gcp('nocreate')); parpool('Threads');end        switch nout        case 1            parfor i=1:xn                x = xa+(i-1)/(xn-1)*xd;                ri = zeros(1,yn);                for j = 1:yn                    y = ya+(j-1)/(yn-1)*yd;                    ri(j) = usercallback(complex(x,y),args{:}); %#ok<PFBNS>                 end                r(:,i) = ri;            end            varargout = {r};        case 3            g = r; b = r;            parfor i=1:xn                x = xa+(i-1)/(xn-1)*xd;                ri = zeros(1,yn); gi = ri; bi = ri;                for j = 1:yn                    y = ya+(j-1)/(yn-1)*yd;                    [ri(j),gi(j),bi(j)] = usercallback(complex(x,y),args{:}); %#ok<PFBNS>                 end                r(:,i) = ri; g(:,i) = gi; b(:,i) = bi;            end            varargout = {r,g,b};        end    end    function varargout = img_gpu_cplx_arrayfun(xr,xn,yr,yn,varargin)        args = values_of(varargin);        z = linspace_meshgrid(xr,xn,yr,yn);        switch nout                    case 1            varargout{1} = arrayfun(usercallback,z,args{:});        case 3            [varargout{1},varargout{2},varargout{3}] = arrayfun(usercallback,z,args{:});        end    end    function varargout = img_gpu_real_matrix(xr,xn,yr,yn,varargin)        args = values_of(varargin);        [x,y] = linspace_meshgrid(xr,xn,yr,yn);        [varargout{1:nout}] = usercallback(x,y,args{:});    end    function varargout = img_gpu_cplx_matrix(xr,xn,yr,yn,varargin)        args = values_of(varargin);        z = linspace_meshgrid(xr,xn,yr,yn);        [varargout{1:nout}] = usercallback(z,args{:});    end    %% rest    if options.gpuArray        if options.Complex            if options.ArrayFun                callback = @img_gpu_cplx_arrayfun;            else % matrix                callback = @img_gpu_cplx_matrix;            end        else % real            if options.ArrayFun                error 'Image cannot run in with gpuArray.arrayfun with real inputs. Use complex callback function.'            else % matrix                callback = @img_gpu_real_matrix;            end        end    else % cpu        if options.Complex            if options.ArrayFun                callback = @img_cpu_cplx_arrayfun;            else % matrix                callback = @img_cpu_cplx_matrix;            end        else % real            if options.ArrayFun                callback = @img_cpu_real_arrayfun;            else % matrix                callback = @img_cpu_real_matrix;            end        end    end        h_ = dimage(parent,label,inputs,callback,corner0,corner1,params,options);    if nargout == 1; h=h_; endendfunction [usercallback,corner0,corner1,params,options] = parse_(inputs,usercallback,corner0,corner1,params,options)    arguments        inputs                  (1,:) cell         usercallback            (1,1) function_handle {mustBeImageCallback(usercallback,inputs)}        corner0                                       {mustBePoint} = [0 0]        corner1                                       {mustBePoint} = [1 1]        params.Interpolation    (1,:) char   {mustBeMember(params.Interpolation,{'nearest','bilinear'})} = 'bilinear';        params.CDataMapping     (1,:) char   {mustBeMember(params.CDataMapping,{'direct','scaled'})}        params.AlphaDataMapping (1,:) char   {mustBeMember(params.AlphaDataMapping,{'none','scaled','direct'})}        params.AlphaData        (:,:) double        params.MaxRenderedResolution        options.Resolution      (1,1) double  {mustBeInteger,mustBePositive}  = 1024        options.Device          (1,:) char {mustBeMember(options.Device,{'gpu','GPU','cpu','CPU'})}     = 'cpu'        options.CallbackType    (1,:) char {mustBeMember(options.CallbackType,{'matrix','vectorize','vectorized'})} = 'matrix'        options.Type            (1,:) char = 'double'        options.Verbose         (1,1) logical = true        options.Representation  (1,:) char {mustBeMember(options.Representation,{'real','complex'})}    end    options.ArrayFun = ~strcmp(options.CallbackType,'matrix');    options.gpuArray = strcmpi(options.Device,'gpu');    options.Complex  = length(inputs)+1 == nargin(usercallback);    if isfield(options,'Representation') && strcmp(options.Representation,'complex')~= options.Complex        error 'The ''Representation'' given does not match the number of arguments of the supplied callback function.'    endendfunction mustBeImageCallback(usercallback,inputs)    nins = length(inputs);    nain = nargin(usercallback);    nout = abs(nargout(usercallback));    if ~any(nain == nins+[1,2])        msgType = ['Callback needs ' int2str(nins+1) ' or ' int2str(nins+2) ' input arguments with the first one either beeing a complex number, or the first two being the X and Y sample positions.'];        throw(MException('Image:callbackWrongNumberOfArguments',msgType));    end    if ~any(nout == [1,3])        msgType = 'Callback needs 1 or 3 output arguments for grayscale or color output.';        throw(MException('Image:callbackWrongNumberOfArguments',msgType));    endendfunction mustBePoint(x)    if ~(isnumeric(x) && length(x)==2 || isa(x,'point_base'))        throwAsCaller(MException('mustBePoint:notPoint','The input must be a position or a point drawing'));    endend